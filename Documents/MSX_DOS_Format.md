MSXフロッピーディスクイメージ内のMSX-DOS FAT12ファイルシステムにアクセスし、ファイル操作やブート領域への書き込みを行うためのC#プログラミングに必要な技術情報について、提供されたソースに基づいて包括的に解説します。

MSXプラットフォームは1980年代初頭に登場し、フロッピーディスクはソフトウェア供給やデータ保存の中心的な役割を果たしました。本資料では、MSX-DOS環境下で広く採用されたFAT12ファイルシステムに焦点を当て、ディスクイメージファイル（特に.DSK）をC#で読み書き・解析するための詳細を提供します。

**1. MSXフロッピーディスクの基礎**

MSXでは主に3.5インチフロッピーディスクが使用され、最も一般的なフォーマットは**720KB（両面倍密度 - 2DD）**です。市販ソフトウェアの配布もこの形式が主流でした。

標準的な720KB MSXフロッピーディスクの物理および論理ジオメトリは以下の通りです:

*   **片面あたりのトラック数:** 80
*   **ヘッド数（面数）:** 2
*   **トラックあたりのセクタ数:** 9
*   **セクタあたりのバイト数:** 512
*   **総セクタ数:** 1440 (80 × 2 × 9)
*   **総容量:** 720 KB (1440 × 512 バイト = 737,280 バイト)

これらのジオメトリ情報は、後述するBPBフィールドにも反映されます。複数の情報源でこれらの値が一貫しているため、C#ディスクイメージリーダーの基本的な前提となります。

**2. MSXフロッピーディスク上のFAT12ファイルシステム構造**

MSX-DOSはファイル管理に主にFAT12ファイルシステムを採用しており、FAT12ボリュームは以下の4つの主要な領域で構成されます:

*   **予約領域:** ブートセクタを含みます。
*   **FAT領域:** ファイルアロケーションテーブル（FAT1およびFAT2）が格納されます。
*   **ルートディレクトリ領域:** ルートディレクトリのエントリが格納されます。
*   **データ領域:** ファイルデータやサブディレクトリデータがクラスタ単位で格納されます。

標準的な720KB MSX-DOSディスクの論理セクタレイアウトは以下の通りです:

*   **ブートセクタ:** 論理セクタ**0**に配置され、サイズは**1**セクタです。BPBとブートコードを含みます。
*   **FAT1:** 論理セクタ**1**から開始し、通常サイズは**9**セクタです（BPB_FATSz16フィールドで指定）。
*   **FAT2:** 論理セクタ**(1 + 9) = 10**から開始し、通常サイズは**9**セクタです。FAT1の複製です。
*   **ルートディレクトリ:** 論理セクタ**(1 + 9 + 9) = 19**から開始し、サイズは通常**7**セクタです。MSX 720KBディスクでは、ルートディレクトリエントリ数（BPB_RootEntCnt）は通常112であり、(112エントリ × 32バイト/エントリ) / 512バイト/セクタ = 7セクタとなります。汎用的なFAT12ドキュメントでは224エントリが示唆されることもありますが、**MSXでは112エントリが標準です**。
*   **データ領域:** 論理セクタ**(19 + 7) = 26**から開始します。総セクタ数から予約領域、FAT、ルートディレクトリのセクタ数を引いた1440 - 26 = 1414セクタがデータ領域です。データ領域の最初のクラスタは常に**クラスタ2**です。

この論理セクタマップは、C#プログラムがディスクイメージ内をナビゲートする上で不可欠です。BPB内のパラメータ（BPB_RsvdSecCnt, BPB_NumFATs, BPB_FATSz16, BPB_RootEntCnt）から、各領域の開始セクタとサイズを計算できます。

**3. FAT12コンポーネントの詳細**

C#でファイルシステムにアクセスするには、これらのコンポーネントの詳細を理解する必要があります。

**3.1. ブートセクタ（セクタ0）**

ディスクイメージの最初の**512バイト**（セクタ0）に位置します。

*   **一般的な構造:**
    *   ジャンプ命令 (0xEB xx 0x90 など)
    *   **BIOSパラメータブロック (BPB)**: ディスクの論理フォーマットを記述。
    *   ブートストラップローダコード: OS (MSXDOS.SYS) のロードなどを開始。
    *   ブートシグネチャ (0x55AA): オフセット510-511。一部カスタムローダーは異なる場合あり。

*   **BIOSパラメータブロック (BPB):**
    *   ブートセクタ内のオフセット**0x0B**から始まるデータ構造です。
    *   MSX-DOS 2.xで導入されました。
    *   すべてのマルチバイトフィールドは**リトルエンディアン**形式で格納されます。
    *   **MSX 720KB標準のBPB値（DOS 2.0 標準）**:
        *   **BPB_BytsPerSec (オフセット 0x0B, 2バイト):** セクタあたりのバイト数。**512 (0x0200)**。
        *   **BPB_SecPerClus (オフセット 0x0D, 1バイト):** クラスタあたりのセクタ数。**2 (MSX 720KB固有)**。PCの720KBディスクは1セクタの場合が多いですが、MSXでは2が標準です。
        *   **BPB_RsvdSecCnt (オフセット 0x0E, 2バイト):** 予約セクタ数。**1 (0x0001)**.
        *   **BPB_NumFATs (オフセット 0x10, 1バイト):** FATの数。**2**.
        *   **BPB_RootEntCnt (オフセット 0x11, 2バイト):** ルートディレクトリエントリ数。**112 (0x0070) (MSX 720KB固有)**。
        *   **BPB_TotSec16 (オフセット 0x13, 2バイト):** 総セクタ数 (65536未満の場合)。**1440 (0x05A0)**.
        *   **BPB_Media (オフセット 0x15, 1バイト):** メディア記述子。**0xF9 (理想的)**。0xF0の場合もあります。
        *   **BPB_FATSz16 (オフセット 0x16, 2バイト):** FATあたりのセクタ数。**9 (0x0009)**.
        *   **BPB_SecPerTrk (オフセット 0x18, 2バイト):** トラックあたりのセクタ数。**9 (0x0009)**.
        *   **BPB_NumHeads (オフセット 0x1A, 2バイト):** ヘッド数。**2 (0x0002)**.
        *   その他のフィールド（BPB_HiddSec, BPB_TotSec32など）もありますが、フロッピーディスクでは通常ゼロまたはBPB_TotSec16が優先されます。

*   **メディア記述子バイト:**
    *   BPB内のBPB_Mediaフィールド（オフセット0x15）に存在します。
    *   **MSX 720KBディスクでは0xF9です**。他のMSXフォーマットには異なる値があります。
    *   **重要な点として、各FATコピーの最初のバイト（論理セクタ1、オフセット0）にもこのメディア記述子バイトが存在することが期待されます**。
    *   **MSX-DOSバージョン1.0は、BPBパラメータを無視し、FATの最初のバイト（メディア記述子バイト）からディスクパラメータを決定することが多いです**。これはPC FATの慣行からの大きな逸脱であり、MSX-DOS 1を対象とするC#ツールは、BPBが信頼できない場合や存在しない場合、**FATのメディア記述子バイトを優先して**ディスクパラメータ（クラスタあたりのセクタ数、FATサイズ、ルートディレクトリエントリ数など）を決定する必要がある場合があります。

**3.2. ファイルアロケーションテーブル (FAT)**

ディスク上のクラスタの割り当て状況を追跡します。FAT1とFAT2の2つの同一コピーが格納されます（BPB_NumFATs=2）。

*   **FAT12エントリ構造:**
    *   各エントリは**12ビット（1.5バイト）長**です。
    *   2つの12ビットエントリは、3つの連続するバイトにパックされます。3バイトがB0, B1, B2の場合、**リトルエンディアン**形式で:
        *   **最初のFATエントリ:** `((B1 & 0x0F) << 8) | B0`。
        *   **2番目のFATエントリ:** `(B2 << 4) | ((B1 & 0xF0) >> 4)`。
    *   C#でこれらの12ビットエントリを読み書きするには、**慎重なビット操作が必要です**。`GetFatEntry(int clusterNumber)` や `SetFatEntry(int clusterNumber, ushort value)` のようなヘルパー関数を作成して、このパッキング/アンパッキングロジックをカプセル化することが強く推奨されます。

*   **FATエントリの解釈（クラスタステータス）:** FATエントリの値は、対応するクラスタの状態を示します:
    *   `0x000`: 未使用（空き）クラスタ
    *   `0x001`: 予約済み（使用すべきでない）
    *   `0x002` - `0xFEF`: 使用中クラスタ。値はチェーン内の次のクラスタ番号
    *   `0xFF0` - `0xFF6`: 予約済みクラスタ値
    *   `0xFF7`: 不良クラスタ
    *   `0xFF8` - `0xFFF`: チェーンの最終クラスタ（EOC - End Of Cluster chain）

*   **クラスタチェーン:** ファイルのディレクトリエントリは最初のクラスタ番号を持ちます。そのクラスタに対応するFATエントリは、次のクラスタ番号またはEOC値を示します。EOCに達するまでFATをたどることで、ファイル全体を構成するクラスタのリストが得られます。

**3.3. ルートディレクトリ**

FATの直後にある固定サイズの領域です。MSX 720KBディスクでは通常**7セクタ（112エントリ）**のサイズです。

*   **ディレクトリエントリフォーマット（32バイト構造）:** ルートディレクトリは32バイトのディレクトリエントリのテーブルです。すべてのマルチバイトフィールドは**リトルエンディアン**です。
    *   **オフセット 0 (8バイト): ファイル名**。大文字、スペース (0x20) でパディング。最初のバイトが0xE5は削除済み、0x00は未使用かつ後続エントリなし、0x05は実際の文字が0xE5。
    *   **オフセット 8 (3バイト): 拡張子**。大文字、スペースでパディング。ピリオドなし。
    *   **オフセット 11 (1バイト): ファイル属性**。ビットマップ形式 (0x01=読取専用, 0x02=隠し, 0x04=システム, 0x08=ボリュームラベル, 0x10=ディレクトリ, 0x20=アーカイブ)。
    *   オフセット 12 (10バイト): 予約済み (通常ゼロ)。
    *   **オフセット 22 (2バイト): 時刻（最終書込）**。パック形式: `hhhhh mmmmmm sssss` (時0-23, 分0-59, 秒/2 0-29)。**リトルエンディアン**。秒は常に偶数になります。
    *   **オフセット 24 (2バイト): 日付（最終書込）**。パック形式: `yyyyyyy mmmm ddddd` (年オフセット1980から(0-127), 月1-12, 日1-31)。**リトルエンディアン**。
    *   **オフセット 26 (2バイト): 開始クラスタ**。ファイルまたはディレクトリデータのデータ領域における最初のクラスタ番号。空ファイルの場合は0。**リトルエンディアン**。
    *   **オフセット 28 (4バイト): ファイルサイズ**。ファイルのバイト単位のサイズ。ディレクトリの場合は0。**リトルエンディアン**。

*   ファイルまたはディレクトリを削除すると、FATのクラスタチェーンがゼロクリアされ、ディレクトリエントリの最初のバイトが0xE5に変更されます。これにより、クラスタが再利用されていなければファイルの復元が可能です。
*   ボリュームラベルは属性バイトで識別される特別なディレクトリエントリとしてルートディレクトリに格納されます。

**3.4. データ領域**

ディスクの大部分を占め、実際のファイル内容やサブディレクトリデータが格納されます。データは**クラスタ**と呼ばれる固定サイズの単位で格納されます。

*   **クラスタあたりのセクタ数:** BPB_SecPerClusで定義され、MSX 720KBディスクでは通常**2セクタ（1024バイト）**です。
*   **開始位置:** データ領域の最初のクラスタは常に**クラスタ2**です。
*   **セクタアドレス計算:** 特定のクラスタの論理セクタアドレス（LBA）は以下の式で計算できます:
    `LBA = FirstDataSector + (ClusterNumber - 2) × BPB_SecPerClus`
    ここで、`FirstDataSector` は、ブートセクタ、FAT、ルートディレクトリの総セクタ数です:
    `FirstDataSector = BPB_RsvdSecCnt + (BPB_NumFATs × BPB_FATSz16) + (BPB_RootEntCnt × 32 / BPB_BytsPerSec)`。

ファイルデータはクラスタのチェーンを占有し、FATをたどることで取得できます。ファイルサイズがクラスタサイズの倍数でない場合、最後のクラスタには未使用領域（スラックスペース）が発生します。

**4. MSX-DOS固有の考慮事項**

*   **ファイルコントロールブロック (FCB):** MSX-DOS 1でファイル操作に使用された36バイトのメモリ内構造。ドライブ番号、ファイル名、サイズ、開始クラスタなどが含まれます。C#でのディスクイメージ解析には直接必要ない場合が多いですが、MSX-DOSの動作理解に役立ちます。
*   **MSX BIOS ディスクI/Oルーチン (PHYDIO):** BIOSアドレス $0144 にある低レベルの**セクタレベル読み書き**ルーチンです。カスタムブートローダーがブートセクタの最初の256バイトを超えるデータをロードするためなどに使用されます。キャリーフラグ、Aレジスタ、B、DE、HLレジスタをパラメータとして使用します。

**5. 一般的なMSXディスクイメージフォーマット**

*   **.DSK:** **最も一般的**で、MSXディスクの生の、非圧縮の、セクタ単位のダンプです. ヘッダは含まれず、ファイルはブートセクタ（セクタ0）から始まります 。720KBディスクの場合、ファイルサイズは正確に**737,280バイト**です。論理セクタがファイル内に順次配置されています。C#ツールは**堅牢な.DSKサポートを優先すべきです**.
*   **.XDF / .DIM:** MSXでは.DSKほど一般的ではありません. これらの形式は他のシステム（Atari, PCなど）でも使用され、ヘッダを含むなど構造がツールによって異なる場合があります. MSXの文脈で遭遇した場合、単純な生イメージであるか、特定のツール固有の形式である可能性があります. .DSKのような標準的なMSXネイティブフォーマットではありません.

**6. C#実装のための主要な考慮事項と手順**

MSXフロッピーディスクイメージ（主に.DSK）をC#で操作するには、以下の手順が必要です:

1.  **ディスクイメージファイルの読み込み:** .DSKファイルをバイナリモードで開きます。これはディスクの全セクタを順次並べたバイト配列として扱えます。論理セクタ番号LBAのデータは、ファイル内の `LBA × BytesPerSector` のオフセットから始まります。
2.  **ブートセクタとBPBの解析:**
    *   ファイルの最初の**512バイト**（セクタ0）を読み取ります。
    *   オフセット**0x0B**からBPBフィールドを抽出します。
    *   各フィールドのサイズ（バイト数）と、**リトルエンディアン**形式でのバイト並び順に注意して値を読み取ります。C#の `System.BitConverter` クラス（`BitConverter.ToInt16`, `BitConverter.ToUInt32` などを使用）が便利です。
    *   BPBパラメータ（BPB_BytsPerSec=512, BPB_SecPerClus=2, BPB_NumFATs=2, BPB_RootEntCnt=112, BPB_FATSz16=9, BPB_TotSec16=1440など）を検証します.
3.  **メディア記述子バイトの処理:**
    *   ブートセクタのオフセット0x15にあるBPB_Mediaを読み取ります.
    *   **論理セクタ1**の先頭バイト（ディスクイメージ内のオフセット 512 × 1 + 0）を読み取ります. これがFATのメディア記述子バイトです.
    *   **MSX-DOS 1互換性が必要な場合、またはBPBの値が疑わしい場合は、FATのメディア記述子バイト（720KBの場合は0xF9）を優先して、クラスタあたりのセクタ数、FATサイズ、ルートディレクトリエントリ数などのディスクパラメータを決定します**.
4.  **FAT領域へのアクセス:**
    *   FAT1の開始セクタはBPB_RsvdSecCnt（通常1）です.
    *   FAT1の開始オフセットは `BPB_RsvdSecCnt × BPB_BytsPerSec` で計算します.
    *   FATエントリ番号に対応するディスクイメージ内のバイトオフセットを計算し、必要な3バイトを読み込みます.
    *   **FAT12エントリのパック/アンパッキングロジック** (`((B1 & 0x0F) << 8) | B0` および `(B2 << 4) | ((B1 & 0xF0) >> 4)`) を使用して、12ビットのクラスタ番号またはステータス値を取得または設定します. このためにヘルパー関数 `GetFatEntry(int clusterNumber)` や `SetFatEntry(int clusterNumber, ushort value)` を実装します.
    *   **クラスタチェーンをたどる**ことで、ファイルやディレクトリが使用しているクラスタのリストを取得できます. これはファイルの読み込みや新しいファイル書き込み時の空きクラスタ検索に必要です。
    *   空きクラスタを見つけるには、FATエントリ値が`0x000`のクラスタを探します.
    *   ファイルを削除するには、そのファイルが使用しているクラスタチェーンに対応するFATエントリ全てを`0x000`に設定します.
5.  **ルートディレクトリ領域へのアクセス:**
    *   ルートディレクトリの開始セクタは `BPB_RsvdSecCnt + (BPB_NumFATs × BPB_FATSz16)` で計算します.
    *   ルートディレクトリの開始オフセットは `(BPB_RsvdSecCnt + BPB_NumFATs × BPB_FATSz16) × BPB_BytsPerSec` で計算します.
    *   ルートディレクトリ領域を読み込みます。通常7セクタ分です.
    *   各セクタには `BPB_BytsPerSec / 32` 個（例: 512/32 = 16個）のディレクトリエントリが含まれます.
    *   BPB_RootEntCnt（通常112）個のエントリを順に処理します.
    *   各32バイトのディレクトリエントリから、フィールド（ファイル名、拡張子、属性、時刻、日付、開始クラスタ、ファイルサイズ）を正しいオフセット、サイズ、**リトルエンディアン変換**を使用して抽出または設定します.
    *   ファイル名/拡張子フィールドはASCII文字とスペースパディングで、ヌル終端ではありません.
    *   ファイル属性バイトを解析/設定することで、ファイルの種類（ファイル、ディレクトリ、ボリュームラベルなど）や属性（読み取り専用、隠し、システム、アーカイブ）を判定/変更できます.
    *   ファイル削除は、ディレクトリエントリの最初のバイトを`0xE5`に設定することで行います.
6.  **データ領域へのアクセス:**
    *   データ領域の開始セクタ `FirstDataSector` を上記の式で計算します.
    *   特定のファイルまたはサブディレクトリのデータは、ディレクトリエントリの開始クラスタから始まるクラスタチェーンをたどることでアクセスできます.
    *   特定のクラスタ番号 `ClusterNumber` に対応するディスクイメージ内の開始オフセットは `FirstDataSector + (ClusterNumber - 2) × BPB_SecPerClus) × BPB_BytsPerSec` で計算できます.
    *   このオフセットから `BPB_SecPerClus × BPB_BytsPerSec` バイトを読み書きすることで、クラスタ単位でファイルデータにアクセスできます.
    *   テキストファイルやバイナリファイルの読み書きは、このクラスタチェーンをたどり、各クラスタのデータをディスクイメージファイルから読み書きすることで実現します。ファイルサイズ（ディレクトリエントリのサイズフィールド）に従ってデータ量を調整します.
    *   新しいファイルやディレクトリを作成するには、FATで十分な数の空きクラスタを見つけ（`0x000`値）、それらをチェーンとしてリンクし、最後にEOCマーカーを設定し、ルートディレクトリまたは親ディレクトリに新しいディレクトリエントリを作成し、開始クラスタ、サイズ、属性などを設定します.
    *   サブディレクトリもルートディレクトリと同様に32バイトエントリのリストですが、データ領域に格納され、サイズは固定ではありません（必要に応じてクラスタが割り当てられます）. ディレクトリを表すディレクトリエントリは、属性バイトのディレクトリフラグ(0x10)がセットされており、ファイルサイズは0、開始クラスタはそのサブディレクトリのデータ（エントリリスト）が格納されているデータ領域の最初のクラスタを指します.

**7. ブート領域へのバイナリファイルやIPLの書き込み**

市販ソフトウェアなどがフロッピーからブートするために、ブート領域（ブートセクタ）にカスタムのバイナリコード（IPLなど）を書き込む必要があります。

*   ブートセクタはディスクイメージの**最初の論理セクタ（セクタ0）**です.
*   .DSKファイルの場合、これはファイルの**最初の512バイト**に直接対応します.
*   **ブートセクタへの書き込み**は、ディスクイメージファイルの先頭512バイトを、用意したカスタムのブートセクタバイナリデータで上書きすることによって行います。
*   カスタムブートセクタを作成する場合、以下の点を考慮する必要があります:
    *   **構造:** 通常、先頭にはジャンプ命令があり、その後にBPBとブートストラップローダーコードが続きます. MSX-DOS互換性を保つ場合は、BPB（特にMSX固有の値）を正確に設定する必要があります.
    *   **MSXディスクROMのロード制限:** MSXディスクROMはブートセクタの最初の**256バイト**のみをメモリ(0xC000)にロードし、アドレス0xC01Eを呼び出します.
    *   **カスタムローダー:** 512バイト全てを使用したり、さらにディスクからデータをロードしたりするカスタムローダーは、最初の256バイトに含まれる初期コード内で、**PHYDIO**のようなBIOSルーチンや独自のディスクアクセスコードを使用して、ブートセクタの残りの部分や他のセクタ（IPL本体、ゲームデータなど）をメモリにロードする必要があります.
    *   標準のMSX-DOSブートセクタは通常、MSXDOS.SYSをロードして実行するコードを含んでいます .

C#でブート領域に書き込むには、ディスクイメージファイルをバイナリ書き込みモードで開き、ファイルの先頭（オフセット0）から512バイトをカスタムブートセクタのバイナリデータで上書きします。ただし、書き込むバイナリデータ自体は、MSXハードウェアやBIOS、MSX-DOSローディングプロセス、そしてMSXディスクROMのブートメカニズム（特に256バイト制限と0xC01Eへのジャンプ）を理解して作成する必要があります.

**8. まとめ**

MSXフロッピーディスクのFAT12ファイルシステムをC#で操作するためには、**標準的な720KBジオメトリ**、**FAT12の領域構成（ブートセクタ、FAT、ルートディレクトリ、データ領域）とその論理セクタレイアウト** を理解することが基礎となります。特に、**BPBの詳細とそのMSX固有の値（クラスタあたり2セクタ、ルートディレクトリエントリ数112、メディア記述子0xF9）**、**FAT12エントリの12ビット構造とパック/アンパック方法**、**ルートディレクトリの32バイトディレクトリエントリ構造とフィールドの解析/設定方法**、そして**クラスタ番号から論理セクタアドレスを計算する式** は、ファイルシステムへのアクセスに必須です。**C#では、これらの構造内のマルチバイト値を読み書きする際に、常にリトルエンディアン変換を行う必要があります**.

ファイル操作（読み書き、一覧、属性変更、削除、ディレクトリ作成/削除）は、FATのクラスタチェーンとルート/サブディレクトリのディレクトリエントリを操作することで実現できます. 一覧取得はディレクトリエントリの読み取りと解析、読み書きはFATチェーンをたどったデータ領域へのアクセス、削除はディレクトリエントリの最初のバイト設定とFATエントリのクリア、属性変更はディレクトリエントリの属性バイト設定、ディレクトリ作成はデータ領域に新しいディレクトリ用のクラスタを割り当ててFATを更新し、親ディレクトリに新しいディレクトリエントリを追加することで行います.

ブート領域への書き込みは、ディスクイメージファイルの先頭512バイトにカスタムバイナリデータを書き込むことで行いますが、書き込むデータはMSXのブートシーケンスとBIOSの挙動（特にPHYDIOや256バイトロード制限）を考慮して設計する必要があります.

主に.DSK形式のディスクイメージを扱うことで、MSX FAT12ファイルシステムへのC#からのアクセスツールを開発するための十分な情報がここに網羅されています. MSX-DOS 1.0がBPBではなくFATのメディア記述子バイトを優先する挙動など、MSX特有のニュアンスにも対応できるよう実装することが望ましいです.

これらの詳細な技術情報と計算式は、C#プログラムがMSXディスクイメージのバイトレベルでの構造を正確に理解し、ファイルシステム操作やブート領域書き込み機能を実現するための強固な基盤となります.